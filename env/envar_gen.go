// Code generated by main.go DO NOT EDIT.

package env

import (
	"log"
	"os"
)

type envarOption struct {
	envarPrefix string
}

type GetEnvarOption func(*envarOption)

func GetEnvarPrefix(prefix string) GetEnvarOption {
	return func(o *envarOption) {
		o.envarPrefix = prefix
	}
}

type Envar struct {
	Roots       *Roots
	GithubHost  *GithubHost
	GithubToken *GithubToken
}

func GetEnvar(opt ...GetEnvarOption) (envar Envar, err error) {
	o := envarOption{envarPrefix: "GOGH_"}
	{
		v := os.Getenv(o.envarPrefix + "ROOTS")
		if v == "" {
			log.Printf("info: there's no envar %sROOTS (%v)", o.envarPrefix, err)
		} else {
			var value Roots
			if err = value.UnmarshalText([]byte(v)); err != nil {
				return envar, err
			}
			envar.Roots = &value
		}
	}
	{
		v := os.Getenv(o.envarPrefix + "GITHUB_HOST")
		if v == "" {
			log.Printf("info: there's no envar %sGITHUB_HOST (%v)", o.envarPrefix, err)
		} else {
			var value GithubHost
			if err = value.UnmarshalText([]byte(v)); err != nil {
				return envar, err
			}
			envar.GithubHost = &value
		}
	}
	{
		v := os.Getenv(o.envarPrefix + "GITHUB_TOKEN")
		if v == "" {
			log.Printf("info: there's no envar %sGITHUB_TOKEN (%v)", o.envarPrefix, err)
		} else {
			var value GithubToken
			if err = value.UnmarshalText([]byte(v)); err != nil {
				return envar, err
			}
			envar.GithubToken = &value
		}
	}
	return
}
