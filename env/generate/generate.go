package generate

import (
	"fmt"
	"os"
	"path/filepath"
	"runtime"

	"github.com/dave/jennifer/jen"
	"github.com/kyoh86/gogh/env/props"
	strcase "github.com/stoewer/go-strcase"
)

type Generator struct {
	PackageName string
	EnvarPrefix string
	ServiceName string

	name string

	storeConfig  bool
	storeKeyring bool
	storeCache   bool
	storeEnvar   bool
}

const (
	pkgYAML    = "gopkg.in/yaml.v3"
	pkgKeyring = "github.com/zalando/go-keyring"
)

func (g *Generator) init() error {
	g.name = "config.generator"
	if _, file, _, ok := runtime.Caller(2); ok {
		cwd, err := os.Getwd()
		if err != nil {
			return err
		}
		rel, err := filepath.Rel(cwd, file)
		if err != nil {
			return err
		}
		g.name = rel
	}

	g.storeConfig = false
	g.storeKeyring = false
	g.storeCache = false
	g.storeEnvar = false

	return nil
}

func (g *Generator) createFile(packagePath string) *jen.File {
	var file *jen.File
	if g.PackageName != "" {
		file = jen.NewFilePathName(packagePath, g.PackageName)
	} else {
		file = jen.NewFilePath(packagePath)
	}
	file.HeaderComment(fmt.Sprintf("// Code generated by %s DO NOT EDIT.", g.name))
	return file
}

func (g *Generator) parseProps(properties []*props.Property) {
	for _, p := range properties {
		g.storeConfig = g.storeConfig || p.StoreConfig
		g.storeKeyring = g.storeKeyring || p.StoreKeyring
		g.storeCache = g.storeCache || p.StoreCache
		g.storeEnvar = g.storeEnvar || p.StoreEnvar
	}
}

func (g *Generator) doMerge(file *jen.File, properties []*props.Property) {
	file.Func().Id("Merge").ParamsFunc(func(mergeParams *jen.Group) {
		if g.storeEnvar {
			mergeParams.Id("envar").Id("Envar")
		}
		if g.storeCache {
			mergeParams.Id("cache").Id("Cache")
		}
		if g.storeKeyring {
			mergeParams.Id("keyring").Id("Keyring")
		}
		if g.storeConfig {
			mergeParams.Id("config").Id("Config")
		}
	}).Params(jen.Id("merged").Id("Merged")).BlockFunc(func(mergeCodes *jen.Group) {
		file.Type().Id("Merged").StructFunc(func(mergedFields *jen.Group) {
			for _, p := range properties {
				mergedFields.Id(p.CamelName).Id(p.ValueTypeID)

				file.Func().Params(jen.Id("m").Id("*Merged")).Id(p.Name).Params().Id(p.ValueTypeID).Block(
					jen.Return(jen.Id("m").Dot(p.CamelName)),
				).Line()

				mergeCodes.Id("merged").Dot(p.CamelName).Op("=").New(jen.Id(p.Name)).Dot("Default").Call().Assert(jen.Id(p.ValueTypeID))
				if p.StoreConfig {
					g.tryMerge(mergeCodes, "config", p)
				}
				if p.StoreKeyring {
					g.tryMerge(mergeCodes, "keyring", p)
				}
				if p.StoreCache {
					g.tryMerge(mergeCodes, "cache", p)
				}
				if p.StoreEnvar {
					g.tryMerge(mergeCodes, "envar", p)
				}
				mergeCodes.Line()
			}
		})
		mergeCodes.Return()
	})
}

func (g *Generator) tryMerge(mergeCodes *jen.Group, srcName string, p *props.Property) {
	mergeCodes.If(jen.Id(srcName).Dot(p.Name).Op("!=").Nil()).Block(
		jen.Id("merged").Dot(p.CamelName).Op("=").Id(srcName).Dot(p.Name).Dot("Value").Call().Assert(jen.Id(p.ValueTypeID)),
	)
}

func (g *Generator) doConfig(file *jen.File, properties []*props.Property) {
	file.Type().Id("Config").StructFunc(func(configFields *jen.Group) {
		for _, p := range properties {
			if !p.StoreConfig {
				continue
			}
			configFields.Id(p.Name).
				Qual(p.Type.PkgPath(), "*"+p.Name).
				Tag(map[string]string{"yaml": p.CamelName + ",omitempty"})
		}
	})
	file.Line()

	file.Func().Id("SaveConfig").
		Params(
			jen.Id("w").Qual("io", "Writer"),
			jen.Id("config").Id("*Config"),
		).
		Add(jen.Id("error")).
		Block(
			jen.Return(
				jen.Qual("gopkg.in/yaml.v3", "NewEncoder").Call(jen.Id("w")).
					Op(".").
					Id("Encode").Call(jen.Id("config")),
			),
		)
	file.Line()
	file.Func().Id("LoadConfig").
		Params(
			jen.Id("r").Qual("io", "Reader"),
		).
		Params(
			jen.Id("config").Id("Config"),
			jen.Err().Id("error"),
		).
		Block(
			jen.Err().Op("=").Qual("gopkg.in/yaml.v3", "NewDecoder").Call(jen.Id("r")).
				Op(".").
				Id("Decode").Call(jen.Op("&").Id("config")),
			jen.Return(),
		)
	file.Line()
}

func (g *Generator) doCache(file *jen.File, properties []*props.Property) {
	file.Type().Id("Cache").StructFunc(func(cacheFields *jen.Group) {
		for _, p := range properties {
			if !p.StoreCache {
				continue
			}
			cacheFields.Id(p.Name).
				Qual(p.Type.PkgPath(), "*"+p.Name).
				Tag(map[string]string{"yaml": p.CamelName + ",omitempty"})
		}
	})
	file.Line()

	file.Func().Id("SaveCache").
		Params(
			jen.Id("w").Qual("io", "Writer"),
			jen.Id("cache").Id("*Cache"),
		).
		Add(jen.Id("error")).
		Block(
			jen.Return(
				jen.Qual("gopkg.in/yaml.v3", "NewEncoder").Call(jen.Id("w")).
					Op(".").
					Id("Encode").Call(jen.Id("cache")),
			),
		)
	file.Line()

	file.Func().Id("LoadCache").
		Params(
			jen.Id("r").Qual("io", "Reader"),
		).
		Params(
			jen.Id("cache").Id("Cache"),
			jen.Err().Id("error"),
		).
		Block(
			jen.Err().Op("=").Qual("gopkg.in/yaml.v3", "NewDecoder").Call(jen.Id("r")).
				Op(".").
				Id("Decode").Call(jen.Op("&").Id("cache")),
			jen.Return(),
		)
	file.Line()
}

func (g *Generator) doEnvar(file *jen.File, properties []*props.Property) {
	file.Type().Id("Envar").StructFunc(func(envarFields *jen.Group) {
		file.Func().Id("LoadEnvar").Params().Params(jen.Id("envar").Id("Envar"), jen.Err().Id("error")).BlockFunc(func(loadEnvarCodes *jen.Group) {
			for _, p := range properties {
				if !p.StoreEnvar {
					continue
				}
				envarFields.Id(p.Name).
					Qual(p.Type.PkgPath(), "*"+p.Name)

				envarName := strcase.UpperSnakeCase(g.EnvarPrefix) + p.SnakeName
				loadEnvarCodes.Block(jen.List(jen.Id("v")).Op(":=").Qual("os", "Getenv").
					Call(jen.Lit(envarName)),
					jen.If(jen.Id("v").Op("==").Lit("")).Block(
						jen.Qual("log", "Printf").Call(jen.Lit("info: there's no envar "+envarName+" (%v)"), jen.Err()),
					).Else().Block(
						jen.Var().Id("value").Qual(p.Type.PkgPath(), p.Name),
						jen.If(
							jen.Err().Op("=").Id("value").Dot("UnmarshalText").Call(jen.Index().Byte().Parens(jen.Id("v"))),
							jen.Err().Op("!=").Nil(),
						).Block(
							jen.Return(jen.Id("envar"), jen.Err()),
						),
						jen.Id("envar").Dot(p.Name).Op("=").Id("&value"),
					),
				)
			}
			loadEnvarCodes.Return()
		}).Line()
	}).Line()
}

func (g *Generator) doKeyring(file *jen.File, packagePath string, properties []*props.Property) {
	file.Type().Id("Keyring").StructFunc(func(keyringFields *jen.Group) {
		file.Func().Id("LoadKeyring").Params().Params(jen.Id("key").Id("Keyring"), jen.Err().Id("error")).BlockFunc(func(loadKeyringCodes *jen.Group) {
			file.Func().Id("SaveKeyring").Params(jen.Id("key").Id("Keyring")).Params(jen.Err().Id("error")).BlockFunc(func(saveKeyringCodes *jen.Group) {
				for _, p := range properties {
					if !p.StoreKeyring {
						continue
					}
					keyringFields.Id(p.Name).
						Qual(p.Type.PkgPath(), "*"+p.Name)
					loadKeyringCodes.Block(jen.List(jen.Id("v"), jen.Err()).Op(":=").Qual(pkgKeyring, "Get").
						Call(jen.Lit(packagePath), jen.Lit(p.KebabName)),
						jen.If(jen.Err().Op("==").Nil()).Block(
							jen.Var().Id("value").Qual(p.Type.PkgPath(), p.Name),
							jen.If(
								jen.Err().Op("=").Id("value").Dot("UnmarshalText").Call(jen.Index().Byte().Parens(jen.Id("v"))),
								jen.Err().Op("!=").Nil(),
							).Block(
								jen.Return(jen.Id("key"), jen.Err()),
							),
							jen.Id("key").Dot(p.Name).Op("=").Id("&value"),
						).Else().Block(
							jen.Qual("log", "Printf").Call(jen.Lit("info: there's no secret in "+p.KebabName+"@"+packagePath+" (%v)"), jen.Err()),
						),
					)
					saveKeyringCodes.Block(
						jen.List(jen.Id("buf"), jen.Err()).Op(":=").Id("key").Dot(p.Name).Dot("MarshalText").Call(),
						jen.If(jen.Err().Op("!=").Nil()).Block(
							jen.Return(jen.Err()),
						),
						jen.If(
							jen.Err().Op(":=").Qual(pkgKeyring, "Set").Call(jen.Lit(packagePath), jen.Lit(p.KebabName), jen.String().Call(jen.Id("buf"))),
							jen.Err().Op("!=").Nil(),
						).Block(
							jen.Return(jen.Err()),
						),
					)
				}
				loadKeyringCodes.Return()
				saveKeyringCodes.Return(jen.Nil())
			})
		}).Line()
	})
}

func (g *Generator) Do(packagePath, outDir string, properties ...*props.Property) error {
	if err := g.init(); err != nil {
		return err
	}

	g.parseProps(properties)
	mergeFile := g.createFile(packagePath)

	g.doMerge(mergeFile, properties)

	storeFile := g.createFile(packagePath)
	storeFile.ImportAlias(pkgYAML, "yaml")
	storeFile.ImportAlias(pkgKeyring, "keyring")

	if g.storeConfig {
		g.doConfig(storeFile, properties)
	}
	if g.storeCache {
		g.doCache(storeFile, properties)
	}
	if g.storeEnvar {
		g.doEnvar(storeFile, properties)
	}
	if g.storeKeyring {
		g.doKeyring(storeFile, packagePath, properties)
	}

	full, err := filepath.Abs(outDir)
	if err != nil {
		return err
	}
	if err := storeFile.Save(filepath.Join(full, "store_gen.go")); err != nil {
		return err
	}
	if err := mergeFile.Save(filepath.Join(full, "merge_gen.go")); err != nil {
		return err
	}
	return nil
}
