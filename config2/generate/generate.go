package generate

import (
	"fmt"
	"os"
	"path/filepath"
	"reflect"
	"runtime"

	"github.com/dave/jennifer/jen"
	"github.com/kyoh86/gogh/config2/types"
	strcase "github.com/stoewer/go-strcase"
)

type Generator struct {
	PackageName string
	EnvarPrefix string
	ServiceName string

	name string
}

const (
	pkgYAML    = "gopkg.in/yaml.v3"
	pkgEnvar   = "github.com/joeshaw/envdecode"
	pkgKeyring = "github.com/zalando/go-keyring"
)

func (g *Generator) init() error {
	g.name = "config.generator"
	if _, file, _, ok := runtime.Caller(2); ok {
		cwd, err := os.Getwd()
		if err != nil {
			return err
		}
		rel, err := filepath.Rel(cwd, file)
		if err != nil {
			return err
		}
		g.name = rel
	}

	return nil
}

func (g *Generator) createFile(packagePath string) *jen.File {
	var file *jen.File
	if g.PackageName != "" {
		file = jen.NewFilePathName(packagePath, g.PackageName)
	} else {
		file = jen.NewFilePath(packagePath)
	}
	file.HeaderComment(fmt.Sprintf("// Code generated by %s DO NOT EDIT.", g.name))
	return file
}

type propertyDescriptor struct {
	Type      reflect.Type
	Name      string
	CamelName string
	SnakeName string
	KebabName string

	ValueType   reflect.Type
	ValueEmpty  interface{}
	ValueTypeID string
}

func (g *Generator) descript(prop types.Property) (p *propertyDescriptor) {
	p = new(propertyDescriptor)
	p.Type = reflect.ValueOf(prop).Type()
	for p.Type.Kind() == reflect.Ptr {
		p.Type = p.Type.Elem()
	}

	p.Name = p.Type.Name()

	p.ValueType = reflect.ValueOf(prop.Value()).Type()
	p.ValueEmpty = reflect.Zero(p.ValueType).Interface()
	p.ValueTypeID = fmt.Sprintf("%T", p.ValueEmpty)

	p.CamelName = strcase.LowerCamelCase(p.Name)
	p.SnakeName = strcase.UpperSnakeCase(p.Name)
	p.KebabName = strcase.KebabCase(p.Name)
	return
}

func (g *Generator) parseProps(props []types.Property) (
	mergedDescs []*propertyDescriptor,
	configDescs []*propertyDescriptor,
	envarDescs []*propertyDescriptor,
	cacheDescs []*propertyDescriptor,
	keyringDescs []*propertyDescriptor,
) {
	for _, prop := range props {
		p := g.descript(prop)
		mergedDescs = append(mergedDescs, p)

		if _, ok := prop.(types.StoreConfigFile); ok {
			configDescs = append(configDescs, p)
		}

		if _, ok := prop.(types.StoreKeyring); ok {
			keyringDescs = append(keyringDescs, p)
		}

		if _, ok := prop.(types.StoreCacheFile); ok {
			cacheDescs = append(cacheDescs, p)
		}

		if _, ok := prop.(types.StoreEnvar); ok {
			envarDescs = append(envarDescs, p)
		}
	}
	return
}

func (g *Generator) doMerge(
	file *jen.File,
	mergedDescs []*propertyDescriptor,
	configDescs []*propertyDescriptor,
	envarDescs []*propertyDescriptor,
	cacheDescs []*propertyDescriptor,
	keyringDescs []*propertyDescriptor,
) {
	file.Func().Id("Merge").ParamsFunc(func(mergeParams *jen.Group) {
		if len(envarDescs) > 0 {
			mergeParams.Id("envar").Id("Envar")
		}
		if len(cacheDescs) > 0 {
			mergeParams.Id("cache").Id("CacheFile")
		}
		if len(keyringDescs) > 0 {
			mergeParams.Id("keyring").Id("Keyring")
		}
		if len(configDescs) > 0 {
			mergeParams.Id("config").Id("ConfigFile")
		}
	}).Params(jen.Id("merged").Id("Merged")).BlockFunc(func(mergeCodes *jen.Group) {
		file.Type().Id("Merged").StructFunc(func(mergedFields *jen.Group) {
			for _, p := range mergedDescs {
				mergedFields.Id(p.CamelName).Id(p.ValueTypeID)

				file.Func().Params(jen.Id("m").Id("*Merged")).Id(p.Name).Params().Id(p.ValueTypeID).Block(
					jen.Return(jen.Id("m").Dot(p.CamelName)),
				).Line()

				mergeCodes.Id("merged").Dot(p.CamelName).Op("=").New(jen.Id(p.Name)).Dot("Default").Call().Assert(jen.Id(p.ValueTypeID))
			}
		})
		mergeCodes.Line()
		for _, p := range configDescs {
			g.tryMerge(mergeCodes, "config", p)
		}
		mergeCodes.Line()
		for _, p := range keyringDescs {
			g.tryMerge(mergeCodes, "keyring", p)
		}
		mergeCodes.Line()
		for _, p := range cacheDescs {
			g.tryMerge(mergeCodes, "cache", p)
		}
		mergeCodes.Line()
		for _, p := range envarDescs {
			g.tryMerge(mergeCodes, "envar", p)
		}
		mergeCodes.Line()
		mergeCodes.Return()
	})
}

func (g *Generator) tryMerge(mergeCodes *jen.Group, srcName string, p *propertyDescriptor) {
	switch p.ValueType.Kind() {
	case reflect.Map, reflect.Array, reflect.Slice:
		mergeCodes.If(jen.Id("len").Call(jen.Id(srcName).Dot(p.Name).Dot("Value").Call().Assert(jen.Id(p.ValueTypeID))).Op("!=").Lit(0)).Block(
			jen.Id("merged").Dot(p.CamelName).Op("=").Id(srcName).Dot(p.Name).Dot("Value").Call().Assert(jen.Id(p.ValueTypeID)),
		)
	default:
		mergeCodes.If(jen.Id(srcName).Dot(p.Name).Dot("Value").Call().Assert(jen.Id(p.ValueTypeID)).Op("!=").Op(fmt.Sprintf("%#+v", p.ValueEmpty))).Block(
			jen.Id("merged").Dot(p.CamelName).Op("=").Id(srcName).Dot(p.Name).Dot("Value").Call().Assert(jen.Id(p.ValueTypeID)),
		)
	}
}

func (g *Generator) doConfig(file *jen.File, configDescs []*propertyDescriptor) {
	if len(configDescs) <= 0 {
		return
	}
	file.Type().Id("ConfigFile").StructFunc(func(configFields *jen.Group) {
		for _, p := range configDescs {
			configFields.Id(p.Name).
				Qual(p.Type.PkgPath(), p.Name).
				Tag(map[string]string{"yaml": p.CamelName})
		}
	})
	file.Line()

	file.Func().Id("SaveConfigFile").
		Params(
			jen.Id("w").Qual("io", "Writer"),
			jen.Id("config").Id("*ConfigFile"),
		).
		Add(jen.Id("error")).
		Block(
			jen.Return(
				jen.Qual("gopkg.in/yaml.v3", "NewEncoder").Call(jen.Id("w")).
					Op(".").
					Id("Encode").Call(jen.Id("config")),
			),
		)
	file.Line()
	file.Func().Id("LoadConfigFile").
		Params(
			jen.Id("r").Qual("io", "Reader"),
		).
		Params(
			jen.Id("config").Id("ConfigFile"),
			jen.Err().Id("error"),
		).
		Block(
			jen.Err().Op("=").Qual("gopkg.in/yaml.v3", "NewDecoder").Call(jen.Id("r")).
				Op(".").
				Id("Decode").Call(jen.Op("&").Id("config")),
			jen.Return(),
		)
	file.Line()
}

func (g *Generator) doCache(file *jen.File, cacheDescs []*propertyDescriptor) {
	if len(cacheDescs) <= 0 {
		return
	}
	file.Type().Id("CacheFile").StructFunc(func(cacheFields *jen.Group) {
		for _, p := range cacheDescs {
			cacheFields.Id(p.Name).
				Qual(p.Type.PkgPath(), p.Name).
				Tag(map[string]string{"yaml": p.CamelName})
		}
	})
	file.Line()

	file.Func().Id("SaveCacheFile").
		Params(
			jen.Id("w").Qual("io", "Writer"),
			jen.Id("cache").Id("*CacheFile"),
		).
		Add(jen.Id("error")).
		Block(
			jen.Return(
				jen.Qual("gopkg.in/yaml.v3", "NewEncoder").Call(jen.Id("w")).
					Op(".").
					Id("Encode").Call(jen.Id("cache")),
			),
		)
	file.Line()

	file.Func().Id("LoadCacheFile").
		Params(
			jen.Id("r").Qual("io", "Reader"),
		).
		Params(
			jen.Id("cache").Id("CacheFile"),
			jen.Err().Id("error"),
		).
		Block(
			jen.Err().Op("=").Qual("gopkg.in/yaml.v3", "NewDecoder").Call(jen.Id("r")).
				Op(".").
				Id("Decode").Call(jen.Op("&").Id("cache")),
			jen.Return(),
		)
	file.Line()
}

func (g *Generator) doEnvar(file *jen.File, envarDescs []*propertyDescriptor) {
	if len(envarDescs) <= 0 {
		return
	}
	file.Type().Id("Envar").StructFunc(func(envarFields *jen.Group) {
		for _, p := range envarDescs {
			envarFields.Id(p.Name).
				Qual(p.Type.PkgPath(), p.Name).
				Tag(map[string]string{"env": strcase.UpperSnakeCase(g.EnvarPrefix) + p.SnakeName})
		}
	})
	file.Line()

	file.Func().Id("LoadEnvar").Params().Params(
		jen.Id("envar").Id("Envar"),
		jen.Err().Id("error"),
	).
		Block(
			jen.Err().Op("=").Qual(pkgEnvar, "Decode").Call(jen.Op("&").Id("envar")),
			jen.If(
				jen.Err().Op("==").Qual(pkgEnvar, "ErrNoTargetFieldsAreSet"),
			).Block(
				jen.Err().Op("=").Nil(),
			),
			jen.Return(),
		)
	file.Line()
}

func (g *Generator) doKeyring(file *jen.File, packagePath string, keyringDescs []*propertyDescriptor) {
	if len(keyringDescs) <= 0 {
		return
	}
	file.Type().Id("Keyring").StructFunc(func(keyringFields *jen.Group) {
		file.Func().Id("LoadKeyring").Params().Params(jen.Id("key").Id("Keyring"), jen.Err().Id("error")).BlockFunc(func(loadKeyringCodes *jen.Group) {
			file.Func().Id("SaveKeyring").Params(jen.Id("key").Id("Keyring")).Params(jen.Err().Id("error")).BlockFunc(func(saveKeyringCodes *jen.Group) {
				for _, p := range keyringDescs {
					keyringFields.Id(p.Name).
						Qual(p.Type.PkgPath(), p.Name)
					loadKeyringCodes.Block(jen.List(jen.Id("v"), jen.Err()).Op(":=").Qual(pkgKeyring, "Get").
						Call(jen.Lit(packagePath), jen.Lit(p.KebabName)),
						jen.If(jen.Err().Op("==").Nil()).Block(
							jen.Var().Id("value").Qual(p.Type.PkgPath(), p.Name),
							jen.If(
								jen.Err().Op("=").Id("value").Dot("UnmarshalText").Call(jen.Index().Byte().Parens(jen.Id("v"))),
								jen.Err().Op("!=").Nil(),
							).Block(
								jen.Return(jen.Id("key"), jen.Err()),
							),
							jen.Id("key").Dot(p.Name).Op("=").Id("value"),
						).Else().Block(
							jen.Qual("log", "Printf").Call(jen.Lit("info: there's no secret in "+p.KebabName+"@"+packagePath+" (%v)"), jen.Err()),
						),
					)
					saveKeyringCodes.Block(
						jen.List(jen.Id("buf"), jen.Err()).Op(":=").Id("key").Dot(p.Name).Dot("MarshalText").Call(),
						jen.If(jen.Err().Op("!=").Nil()).Block(
							jen.Return(jen.Err()),
						),
						jen.If(
							jen.Err().Op(":=").Qual(pkgKeyring, "Set").Call(jen.Lit(packagePath), jen.Lit(p.KebabName), jen.String().Call(jen.Id("buf"))),
							jen.Err().Op("!=").Nil(),
						).Block(
							jen.Return(jen.Err()),
						),
					)
				}
				loadKeyringCodes.Return()
				saveKeyringCodes.Return(jen.Nil())
			})
		}).Line()
	})
}

func (g *Generator) Do(packagePath, outDir string, props ...types.Property) error {
	if err := g.init(); err != nil {
		return err
	}

	mergedDescs, configDescs, envarDescs, cacheDescs, keyringDescs := g.parseProps(props)
	mergeFile := g.createFile(packagePath)

	g.doMerge(mergeFile, mergedDescs, configDescs, envarDescs, cacheDescs, keyringDescs)

	storeFile := g.createFile(packagePath)
	storeFile.ImportAlias(pkgYAML, "yaml")
	storeFile.ImportAlias(pkgKeyring, "keyring")

	g.doConfig(storeFile, configDescs)
	g.doCache(storeFile, cacheDescs)
	g.doEnvar(storeFile, envarDescs)
	g.doKeyring(storeFile, packagePath, keyringDescs)

	full, err := filepath.Abs(outDir)
	if err != nil {
		return err
	}
	if err := storeFile.Save(filepath.Join(full, "store_gen.go")); err != nil {
		return err
	}
	if err := mergeFile.Save(filepath.Join(full, "merge_gen.go")); err != nil {
		return err
	}
	return nil
}
