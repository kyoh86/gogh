// Code generated by MockGen. DO NOT EDIT.
// Source: ./store/store.go
//
// Generated by this command:
//
//	mockgen -source ./store/store.go -destination ./store_mock/gen_store_mock.go -package store_mock
//

// Package store_mock is a generated GoMock package.
package store_mock

import (
	context "context"
	reflect "reflect"

	store "github.com/kyoh86/gogh/v4/core/store"
	gomock "go.uber.org/mock/gomock"
)

// MockContent is a mock of Content interface.
type MockContent struct {
	ctrl     *gomock.Controller
	recorder *MockContentMockRecorder
	isgomock struct{}
}

// MockContentMockRecorder is the mock recorder for MockContent.
type MockContentMockRecorder struct {
	mock *MockContent
}

// NewMockContent creates a new mock instance.
func NewMockContent(ctrl *gomock.Controller) *MockContent {
	mock := &MockContent{ctrl: ctrl}
	mock.recorder = &MockContentMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockContent) EXPECT() *MockContentMockRecorder {
	return m.recorder
}

// HasChanges mocks base method.
func (m *MockContent) HasChanges() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "HasChanges")
	ret0, _ := ret[0].(bool)
	return ret0
}

// HasChanges indicates an expected call of HasChanges.
func (mr *MockContentMockRecorder) HasChanges() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HasChanges", reflect.TypeOf((*MockContent)(nil).HasChanges))
}

// MarkSaved mocks base method.
func (m *MockContent) MarkSaved() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "MarkSaved")
}

// MarkSaved indicates an expected call of MarkSaved.
func (mr *MockContentMockRecorder) MarkSaved() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MarkSaved", reflect.TypeOf((*MockContent)(nil).MarkSaved))
}

// MockLoader is a mock of Loader interface.
type MockLoader[T any] struct {
	ctrl     *gomock.Controller
	recorder *MockLoaderMockRecorder[T]
	isgomock struct{}
}

// MockLoaderMockRecorder is the mock recorder for MockLoader.
type MockLoaderMockRecorder[T any] struct {
	mock *MockLoader[T]
}

// NewMockLoader creates a new mock instance.
func NewMockLoader[T any](ctrl *gomock.Controller) *MockLoader[T] {
	mock := &MockLoader[T]{ctrl: ctrl}
	mock.recorder = &MockLoaderMockRecorder[T]{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockLoader[T]) EXPECT() *MockLoaderMockRecorder[T] {
	return m.recorder
}

// Load mocks base method.
func (m *MockLoader[T]) Load(ctx context.Context, initial func() T) (T, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Load", ctx, initial)
	ret0, _ := ret[0].(T)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Load indicates an expected call of Load.
func (mr *MockLoaderMockRecorder[T]) Load(ctx, initial any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Load", reflect.TypeOf((*MockLoader[T])(nil).Load), ctx, initial)
}

// Source mocks base method.
func (m *MockLoader[T]) Source() (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Source")
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Source indicates an expected call of Source.
func (mr *MockLoaderMockRecorder[T]) Source() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Source", reflect.TypeOf((*MockLoader[T])(nil).Source))
}

// MockSaver is a mock of Saver interface.
type MockSaver[T store.Content] struct {
	ctrl     *gomock.Controller
	recorder *MockSaverMockRecorder[T]
	isgomock struct{}
}

// MockSaverMockRecorder is the mock recorder for MockSaver.
type MockSaverMockRecorder[T store.Content] struct {
	mock *MockSaver[T]
}

// NewMockSaver creates a new mock instance.
func NewMockSaver[T store.Content](ctrl *gomock.Controller) *MockSaver[T] {
	mock := &MockSaver[T]{ctrl: ctrl}
	mock.recorder = &MockSaverMockRecorder[T]{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockSaver[T]) EXPECT() *MockSaverMockRecorder[T] {
	return m.recorder
}

// Save mocks base method.
func (m *MockSaver[T]) Save(ctx context.Context, v T, force bool) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Save", ctx, v, force)
	ret0, _ := ret[0].(error)
	return ret0
}

// Save indicates an expected call of Save.
func (mr *MockSaverMockRecorder[T]) Save(ctx, v, force any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Save", reflect.TypeOf((*MockSaver[T])(nil).Save), ctx, v, force)
}

// Source mocks base method.
func (m *MockSaver[T]) Source() (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Source")
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Source indicates an expected call of Source.
func (mr *MockSaverMockRecorder[T]) Source() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Source", reflect.TypeOf((*MockSaver[T])(nil).Source))
}

// MockStore is a mock of Store interface.
type MockStore[T store.Content] struct {
	ctrl     *gomock.Controller
	recorder *MockStoreMockRecorder[T]
	isgomock struct{}
}

// MockStoreMockRecorder is the mock recorder for MockStore.
type MockStoreMockRecorder[T store.Content] struct {
	mock *MockStore[T]
}

// NewMockStore creates a new mock instance.
func NewMockStore[T store.Content](ctrl *gomock.Controller) *MockStore[T] {
	mock := &MockStore[T]{ctrl: ctrl}
	mock.recorder = &MockStoreMockRecorder[T]{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockStore[T]) EXPECT() *MockStoreMockRecorder[T] {
	return m.recorder
}

// Load mocks base method.
func (m *MockStore[T]) Load(ctx context.Context, initial func() T) (T, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Load", ctx, initial)
	ret0, _ := ret[0].(T)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Load indicates an expected call of Load.
func (mr *MockStoreMockRecorder[T]) Load(ctx, initial any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Load", reflect.TypeOf((*MockStore[T])(nil).Load), ctx, initial)
}

// Save mocks base method.
func (m *MockStore[T]) Save(ctx context.Context, v T, force bool) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Save", ctx, v, force)
	ret0, _ := ret[0].(error)
	return ret0
}

// Save indicates an expected call of Save.
func (mr *MockStoreMockRecorder[T]) Save(ctx, v, force any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Save", reflect.TypeOf((*MockStore[T])(nil).Save), ctx, v, force)
}

// Source mocks base method.
func (m *MockStore[T]) Source() (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Source")
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Source indicates an expected call of Source.
func (mr *MockStoreMockRecorder[T]) Source() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Source", reflect.TypeOf((*MockStore[T])(nil).Source))
}
